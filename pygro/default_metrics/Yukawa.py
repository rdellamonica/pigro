import pygro

class Yukawa(pygro.Metric):
    def __init__(self, **kwargs):
        self.initialized = 0
        self.initialized_metric = 0
        self.geodesic_engine_linked = False
        metric_json = {"name": "Yukawa-like f(R)", "g": [["-(1-2*M*(delta*exp(-r/lamb)+1)/(r*(delta+1)))", "0", "0", "0"], ["0", "1+2*M*(delta*exp(-r/lamb)+1)/(r*(delta+1))", "0", "0"], ["0", "0", "r**2", "0"], ["0", "0", "0", "r**2*(sin(theta))**2"]], "x": ["t", "r", "theta", "phi"], "g_inv": [["(-delta*r*exp(r/lamb) - r*exp(r/lamb))/(-2*M*delta - 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb))", "0", "0", "0"], ["0", "(delta*r*exp(r/lamb) + r*exp(r/lamb))/(2*M*delta + 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb))", "0", "0"], ["0", "0", "r**(-2)", "0"], ["0", "0", "0", "1/(r**2*sin(theta)**2)"]], "eq_x": ["u_t", "u_r", "u_theta", "u_phi"], "eq_u": ["-u_r*u_t*(-delta*r*exp(r/lamb) - r*exp(r/lamb))*(-2*M*delta*exp(-r/lamb)/(lamb*r*(delta + 1)) - 2*M*(delta*exp(-r/lamb) + 1)/(r**2*(delta + 1)))/(-2*M*delta - 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb))", "r*u_phi**2*(delta*r*exp(r/lamb) + r*exp(r/lamb))*sin(theta)**2/(2*M*delta + 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb)) + r*u_theta**2*(delta*r*exp(r/lamb) + r*exp(r/lamb))/(2*M*delta + 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb)) - u_r**2*(delta*r*exp(r/lamb) + r*exp(r/lamb))*(-2*M*delta*exp(-r/lamb)/(lamb*r*(delta + 1)) - 2*M*(delta*exp(-r/lamb) + 1)/(r**2*(delta + 1)))/(2*(2*M*delta + 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb))) - u_t**2*(delta*r*exp(r/lamb) + r*exp(r/lamb))*(2*M*delta*exp(-r/lamb)/(lamb*r*(delta + 1)) + 2*M*(delta*exp(-r/lamb) + 1)/(r**2*(delta + 1)))/(2*(2*M*delta + 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb)))", "u_phi**2*sin(theta)*cos(theta) - 2*u_r*u_theta/r", "-2*u_phi*u_theta*cos(theta)/sin(theta) - 2*u_phi*u_r/r"], "u0_timelike": "-sqrt((2*M*delta*u_r**2 + 2*M*u_r**2*exp(r/lamb) + delta*r**3*u_phi**2*exp(r/lamb)*sin(theta)**2 + delta*r**3*u_theta**2*exp(r/lamb) + delta*r*u_r**2*exp(r/lamb) + delta*r*exp(r/lamb) + r**3*u_phi**2*exp(r/lamb)*sin(theta)**2 + r**3*u_theta**2*exp(r/lamb) + r*u_r**2*exp(r/lamb) + r*exp(r/lamb))/(-2*M*delta - 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb)))", "u0_null": "-sqrt((2*M*delta*u_r**2 + 2*M*u_r**2*exp(r/lamb) + delta*r**3*u_phi**2*exp(r/lamb)*sin(theta)**2 + delta*r**3*u_theta**2*exp(r/lamb) + delta*r*u_r**2*exp(r/lamb) + r**3*u_phi**2*exp(r/lamb)*sin(theta)**2 + r**3*u_theta**2*exp(r/lamb) + r*u_r**2*exp(r/lamb))/(-2*M*delta - 2*M*exp(r/lamb) + delta*r*exp(r/lamb) + r*exp(r/lamb)))"}
        self.load_metric_from_json(metric_json, **kwargs)